\section{System Design}
\label{design}
Here we cover the design of our system architecture.
We first state the overall scope we used to work toward our design goals of accuracy, transparency, scalability, and efficiency.
We then describe the main components of our system--namely, the client and broker
programs, followed by the communication protocol that these entities use.
In these sections we will highlight specific design decisions that we needed to address
in order to achieve our stated goals,
and explain how we handled them.
We finish this section with a [NECESSARY?].

\subsection{Scope}
Before we could begin designing a distributed file hosting architecture,
it was necessary to define the scope for our work.
Our assumptions for this work are as follows:
\begin{itemize}
    \item \emph{Connection reliability:} The individual components of our system
    connect via TCP stream sockets in order to pass messages and data.
    This precludes reliable transmission of data, with failure detection
    and subsequent retransmission. While TCP handshakes will increase
    the latency of message passing, reliable transmission allows
    us to focus on the accuracy of our system.
    [FILL IN possibly point to future work in unreliable transmission?]
    \item \emph{Conflict resolution:} Automated synchronization necessarily implies
    instances of conflicts between closely committed updates.
    Previous work (\cite{shakir1998system,hurley2004collaborative}) has been done on conflict resolution strategies in distributed domains,
    generating several viable solutions.
    We rely on these promising schemes in place of proposing our own solution,
    which is beyond the scope of this work.
    \item \emph{Security:} Our work falls in the domain
    of networked applications, and therefore is subject
    to a litany of network security attacks.
    The security community has addressed such threats
    in a body of literature that is too vast to properly reference.
    Instead we indicate where we leverage secure hashing algorithms (SHA)
    and public key infrastructure (PKI) to facilitate
    the integrity and privacy of our system,
    and leave the rest to the capable hands of security researchers.
    \end{itemize}

\subsection{D-Sync Architecture}
The D-Sync architecture consists of clients and brokers,
networked via TCP stream sockets.
In the following sections we will describe the primary
components and actions of each entity,
as well as any design decisions made along the way.


\comment {
    \emph{Event ordering:} Since our proposed architecture 
    synchronizes data across different machines, it 
    requires an event ordering scheme for evaluating update time.
    We leverage Lamport timestamps to this end,
    which allow a partial ordering of events based
    on happened-before logic.
    [FILL IN possibly point to vector clock future work]
}

\subsubsection{Client}
%clients
        %description (function, local storage)
        %actions
            %discovery
                %what needs to be given?
                %secret key-hash keys
                %broker location/auth key
            %initialization
            %local update
            %broker ACK
            %broker PUSHBACK
            %broker PULL

\subsubsection{Broker}
%brokers
    %description (function, local storage)
    %actions
        %connect
        %client RQST
        %[distr] broker PUSH
        %[distr] broker PULL

\subsection{Communication Protocol}
    %communication protocol
        %Connect
        %Batch Request
        %Request
        %Ack
        %Retrieve
        %Push
    %other considerations
        %security

\comment{
    \item \textbf{Read Once, Write All (ROWA):} ROWA systems allow read operations to merely fetch the requested data from the most convenient location, while write operations are required to update all replicas. 
    Read operations are therefore guaranteed to be correct, but if replica-storing node fails during a write operation, then that write operation will fail. (PE: necessarily true?)
}

\comment {
    \subsection{Client}
    Clients are thin--they have local data storage and the broker program, which handles their read and write requests.
    We implement clients as individual processes with local storage and a database to track timestamps and revision numbers.
    Clients watch their repository directory for any changes (additions, deletions, modifications).\newline\newline
    Upon initialization:
    \begin{enumerate}
    \item update DB
    \item start observer
    \item connect to broker
    \item push entire directory as request
    \end{enumerate}
    Upon change event:
    \begin{enumerate}
    \item append change to queue
    \item send request to broker
    \end{enumerate}
    Upon broker request ack:
    \begin{enumerate}
    \item dequeue change
    \item send change to broker
    \end{enumerate}
    Upon broker pushback:
    \begin{enumerate}
    \item update DB
    \item receive change (lock?)
    \end{enumerate}

    \subsection{Broker}
    The purpose of the broker in our scheme is to handle read and write requests of the individual clients. 
    Group management: the broker keeps record of all clients participating in the system.
    A broker keeps its own copy of the revision numbers.
    \newline\newline
    Upon receiving a connection:
    \begin{enumerate}
    \item recv request
    \item lock
    \item compare request to local DB (revision numbers)
    \item if valid respond with ack, else:
      \begin{enumerate}
        \item respond with push
        \item RETRIEVE
        \item PUSHBACK
    \end{enumerate}
    \item unlock
    \end{enumerate}
    Upon receiving client changes:
    \begin{enumerate}
    \item update DB
    \item PUSH
    \end{enumerate}

    \subsection{Messages}
    CONNECT

    REQUEST

    ACK

    RETRIEVE

    PUSHBACK

    PUSH

    (fill in)
    \subsection{Network}
    Clients and brokers use TCP stream sockets to communicate with one another.

    \subsection{Issues Resolved}
    What if a client dies? Just consider it gone by the system.\newline\newline
    What if a client dies after it makes a request? Drop the request.\newline\newline
    Client re-emerges (death + reentry) with updated files? Use local database to check timestamps, update local database, and push changes.\newline\newline
    How to handle group managament? At the broker.\newline\newline
    What if the broker dies? All clients save state..upon reentering the broker has fresh local storage

    LAMPORT TIMESTAMPS!       
}

