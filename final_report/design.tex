\section{System Design}
\label{design}
Here we cover the design of our system architecture.
We first state the overall scope we used to work toward our design goals of accuracy, transparency, scalability, and efficiency.
We then describe the main components of our system--namely, the client and broker
programs, followed by the communication protocol that these entities use.
In these sections we will highlight specific design decisions that we needed to address
in order to achieve our stated goals,
and explain how we handled them.

\subsection{Scope}
Before we could begin designing a distributed file hosting architecture,
it was necessary to define the scope for our work.
Our assumptions for this work are as follows:
\begin{itemize}
    \item \emph{Connection reliability:} The individual components of our system
    connect via TCP stream sockets in order to pass messages and data.
    This precludes reliable transmission of data, with failure detection
    and subsequent retransmission. While TCP handshakes will increase
    the latency of message passing, reliable transmission allows
    us to focus on the accuracy of our system.
    \item \emph{Conflict resolution:} Automated synchronization necessarily implies
    instances of conflicts between closely committed updates.
    Previous work (\cite{shakir1998system,hurley2004collaborative}) has been done on conflict resolution strategies in distributed domains,
    generating several viable solutions.
    We rely on these promising schemes in place of proposing our own solution,
    which is beyond the scope of this work.
    \item \emph{Security:} Our work falls in the domain
    of networked applications, and therefore is subject
    to a litany of network security attacks.
    The security community has addressed such threats
    in a body of literature that is too vast to properly reference.
    Instead we indicate where we leverage secure hashing algorithms (SHA)
    and public key infrastructure (PKI) to facilitate
    the integrity and privacy of our system,
    and leave the rest to the capable hands of security researchers.
    \end{itemize}

Having declared the scope of our project,
we now detail the D-Sync architecture.
The main components of this system are clients and brokers,
networked via TCP stream sockets.
In the following sections we will describe the primary
components and actions of each entity,
as well as any design decisions made along the way.

\subsection{Major Design Decisions}
The first design decision that we needed to cover was the synchronization
model.
We had a number of options, but to best ensure
that our system maintained data consistency
we chose Read Once Write All (ROWA). In this model,
updates are pushed to all clients in the working group
at once.
When a client needs to pull data,
the system merely fetches it from the nearest client.

In addition to selecting a synchronization model,
we also needed to specify a communication model for our system.
We chose an asynchronous communication model,
allowing users to collaborate without blocking on updates.


With the major design decisions covered, we next turn to 
the client and broker programs.

\subsection{Client}
The client program is essentially a thin local program
for handling changes to a user's local workspace.
On the one hand, it must watch the client's workspace
and detect changes to files and folders.
In order to detect changes,
the client must maintain local storage tracking
the current status of the workspace.

One of the first design decisions we had to handle on the client-side
is the discovery phase: how does a client connect to the rest of the 
D-Sync architecture?
We note that given that working groups who would potentially
use this system have inherent privacy concerns,
it is reasonable to assume that they would have interest in a secure system.
Therefore, users must be invited to the working group and the system in general.
An invited user could obtain connection information for a specific broker
with which he could initially connect to.
Such offline information would also include any public keys needed
to verify the broker.

Once a client has access to the network,
it can begin to collaborate with the working group.
In the next sections, we cover the various actions
that a client performs.

\subsubsection{Initialization}
In order to implement our ROWA synchronization model,
we had to take a unique approach to initializing a client.
When a client comes online,
it immediately needs to check whether its offline changes
are ahead of the system and push those changes.
After this push, the system should make the client
pull down any changes that it is behind on.
We call this initial phase the \textbf{batch update}.

\subsubsection{Other Actions}
The remaining actions of the client are fairly trivial.
When the client detects an update to the local workspace,
it sends the system a request (RQST) message containing a hash
of the filename and the file's revision number.
The client then waits asynchronously for an acknowledgement
(ACK) from the broker.
We cover the need for a request message when we discuss the broker
in section\ref{broker}.
Upon receiving an ACK, the client updates the revision
number of the changed file,
and pushes that file to the system.

The only other required actions of the client are to handle
pushes coming from the broker.
If the broker pushes down a change,
the client should accept that change and update both its
local workspace and the associated file's revision number.
The client should not have to worry about calculating
revision numbers itself--that logic is handled on the broker-side.

We next turn to the broker,
the primary component of our system.
As with the client, we describe the broker's primary
function and actions.

\subsubsection{Broker}
\label{broker}
%brokers
    %description (function, local storage)
    %actions
        %connect
        %client RQST
        %[distr] broker PUSH
        %[distr] broker PULL

\subsection{Communication Protocol}
    %communication protocol
        %Connect
        %Batch Request
        %Request
        %Ack
        %Retrieve
        %Push
    %other considerations
        %security

\comment{
    \item \textbf{Read Once, Write All (ROWA):} ROWA systems allow read operations to merely fetch the requested data from the most convenient location, while write operations are required to update all replicas. 
    Read operations are therefore guaranteed to be correct, but if replica-storing node fails during a write operation, then that write operation will fail. (PE: necessarily true?)
}

\comment {
    \subsection{Client}
    Clients are thin--they have local data storage and the broker program, which handles their read and write requests.
    We implement clients as individual processes with local storage and a database to track timestamps and revision numbers.
    Clients watch their repository directory for any changes (additions, deletions, modifications).\newline\newline
    Upon initialization:
    \begin{enumerate}
    \item update DB
    \item start observer
    \item connect to broker
    \item push entire directory as request
    \end{enumerate}
    Upon change event:
    \begin{enumerate}
    \item append change to queue
    \item send request to broker
    \end{enumerate}
    Upon broker request ack:
    \begin{enumerate}
    \item dequeue change
    \item send change to broker
    \end{enumerate}
    Upon broker pushback:
    \begin{enumerate}
    \item update DB
    \item receive change (lock?)
    \end{enumerate}

    \subsection{Broker}
    The purpose of the broker in our scheme is to handle read and write requests of the individual clients. 
    Group management: the broker keeps record of all clients participating in the system.
    A broker keeps its own copy of the revision numbers.
    \newline\newline
    Upon receiving a connection:
    \begin{enumerate}
    \item recv request
    \item lock
    \item compare request to local DB (revision numbers)
    \item if valid respond with ack, else:
      \begin{enumerate}
        \item respond with push
        \item RETRIEVE
        \item PUSHBACK
    \end{enumerate}
    \item unlock
    \end{enumerate}
    Upon receiving client changes:
    \begin{enumerate}
    \item update DB
    \item PUSH
    \end{enumerate}

    \subsection{Messages}
    CONNECT

    REQUEST

    ACK

    RETRIEVE

    PUSHBACK

    PUSH

    (fill in)
    \subsection{Network}
    Clients and brokers use TCP stream sockets to communicate with one another.

    \subsection{Issues Resolved}
    What if a client dies? Just consider it gone by the system.\newline\newline
    What if a client dies after it makes a request? Drop the request.\newline\newline
    Client re-emerges (death + reentry) with updated files? Use local database to check timestamps, update local database, and push changes.\newline\newline
    How to handle group managament? At the broker.\newline\newline
    What if the broker dies? All clients save state..upon reentering the broker has fresh local storage

    LAMPORT TIMESTAMPS!       
}

